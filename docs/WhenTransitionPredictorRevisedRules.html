<!DOCTYPE html>
<html>

        <head>
            
            <title>Auto-CS doc</title>

            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
            <meta name="description" content="WhenTransitionPredictorRevisedRules. Predict hand transition moments with a revised rule-based system." />

            <link rel="logo icon" href="./statics/autocs32x32.ico" />
            <link rel="stylesheet" href="./Whakerexa-2.0/wexa_statics/css/wexa.css" type="text/css" />
            <link rel="stylesheet" href="./Whakerexa-2.0/wexa_statics/css/layout.css" type="text/css" />
            <link rel="stylesheet" href="./Whakerexa-2.0/wexa_statics/css/book.css" type="text/css" />
            <link rel="stylesheet" href="./Whakerexa-2.0/wexa_statics/css/menu.css" type="text/css" />
            <link rel="stylesheet" href="./Whakerexa-2.0/wexa_statics/css/code.css" type="text/css" />
            <link rel="stylesheet" href="./statics/clamming.css" type="text/css" />

            <!-- Whakerexa JS loader: ES6 modules on http(s), bundle on file:// -->
            <script>
            (function () {
              const usingFile = (window.location.protocol === 'file:');
              const s = document.createElement('script');
            
              if (usingFile) {
                s.src = './Whakerexa-2.0/wexa_statics/js/wexa.bundle.js';
              } else {
                s.type = 'module';
                s.src = './Whakerexa-2.0/wexa_statics/js/wexa.js';
              }
            
              s.onload = function () {
                window.Wexa.onload.addLoadFunction(function () {
                  const book = new window.Wexa.Book("main-content");
                  book.fill_table(false);
                });
              };
            
              document.head.appendChild(s);
            })();
            </script>

       </head>
       
       <body class="light">
        <header>

            <a role="button" class="skip" href="#main-content" aria-label="Go to main content">
                Go to main content
            </a>
            <nav>
                <ul>
                    <li>
                        <button id="btn-contrast" role="menuitem" class="print-off" onclick="window.Wexa.accessibility.switch_contrast_scheme()" aria-label="Contrast">
                            <img class="nav-item-img" src="./Whakerexa-2.0/wexa_statics/icons/contrast_switcher.jpg" alt="Contrast" id="img-contrast"/>
                        </button>
                    </li>
                    <li>
                        <button id="btn-theme" class="print-off" role="menuitem" onclick="window.Wexa.accessibility.switch_color_scheme()" aria-label="Theme" >
                            <img class="nav-item-img" src="./Whakerexa-2.0/wexa_statics/icons/theme_switcher.png" alt="Theme" id="img-theme"/>
                        </button>
                    </li>
                </ul>
            </nav>
        
    <h1>Auto-CS 2.0</h1>
        <p><img class="small-logo" src="./statics/autocs.png" alt="Software logo"/></p>
        <p><a class="external-link" href="https://sourceforge.net/projects/autocs/">https://sourceforge.net/projects/autocs/</a></p>
    </header>
    <nav id="nav-book" class="side-nav">
    <h1>Auto-CS 2.0</h1>
    <img class="small-logo center" src="./statics/autocs.png" alt=""/>
        <p><a class="external-link" href="https://sourceforge.net/projects/autocs/">https://sourceforge.net/projects/autocs/</a></p>
    <ul>
<li><a role="button" tabindex="0" href="CuedSpeech.whenhand.html"> &crarr; Prev. Module</a></li>
<li><a role="button" tabindex="0" href="WhenTransitionPredictorRules.html"> &uarr; Prev. Class</a></li>
<li><a role="button" tabindex="0" href="index.html"> &#8962; Index</a></li>
<li><a role="button" tabindex="0" aria-disabled="true"> &darr; Next Class</a></li>
<li><a role="button" tabindex="0" href="CuedSpeech.wherecue.html"> &rdsh; Next Module</a></li>
    </ul>
    <h2>Table of Contents</h2>
    <ul id="toc"></ul>
    <hr>
    <p><small>Automatically created</small></p><p><small>by <a class="external-link" href="https://clamming.sf.net">ClammingPy</a></small></p>
</nav>
    <main id="main-content">
    <section id="#CuedSpeech.whenhand.transition">    <h1>Module CuedSpeech.whenhand.transition</h1>
<section id="#WhenTransitionPredictorRevisedRules">
<h2>Class WhenTransitionPredictorRevisedRules</h2>

<section>
<h3 id="#description_WhenTransitionPredictorRevisedRules">Description</h3>
    <article class="docstring">
<p><em>Predict hand transition moments with a revised rule-based system.</em></p>

<p>The system implements the following rules to estimate [M1;M2]:
- The structure of the key matters.
- M2 is before A1, like in (Duchnowski et al. 1998) but not that much
- The position transition of the first key after a silence (from neutral)
is very early before the sound. The M2 of the 2nd key of a speech segment
is also earlier than the next ones.
- The position transition from the last key of a speech segment to the
neutral one (to a long silence), is delayed. See predict<em>pos</em>to_neutral().
- They are estimated proportionally to the average duration of <em>observed</em>
A1A3 intervals.</p>

    </article>
</section>
<section>
<h3 id="#constructor_WhenTransitionPredictorRevisedRules">Constructor</h3>
    <article class="docstring">
<p><em>Instantiate a custom hand transition moment's predictor.</em></p>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Instantiate a custom hand transition moment&#39;s predictor.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">WhenTransitionPredictorRevisedRules</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_description</span> <span class="o">=</span> <span class="n">MSG_DESCRIPTION_RULES</span>
</code></pre></div>

    </details>


</section>
<section>
<h3 id="#public_fct_WhenTransitionPredictorRevisedRules">Public functions</h3>
<h4>predict_position</h4>

    <article class="docstring">
<p><em>Predict [M1;M2] the moments when the hand is moving.</em></p>

<h5>Parameters</h5>

<ul>
<li><strong>rank</strong>: (<em>int</em>) The rank of the key. 0=silence, 1=1st key after a silence, etc.</li>
</ul>

<h5>Returns</h5>

<ul>
<li><strong>(m1</strong>: float, m2: float)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">predict_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [M1;M2] the moments when the hand is moving.</span>

<span class="sd">        :param rank: (int) The rank of the key. 0=silence, 1=1st key after a silence, etc.</span>
<span class="sd">        :return: (m1: float, m2: float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_pos_to_neutral</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_pos_from_neutral</span><span class="p">()</span>
    <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_pos_generic</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a3</span><span class="p">)</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
</code></pre></div>

    </details>


<h4>predict_shape</h4>

    <article class="docstring">
<p><em>Predict [D1;D2] the moments when fingers are changing.</em></p>

<p>It is considered but not proved that:</p>

<ul>
<li>D1 is after M1; and</li>
<li>D2 is before M2;</li>
<li>[D1;D2] is a relative fast change and must occur asap.</li>
</ul>

<h5>Parameters</h5>

<ul>
<li><strong>rank</strong>: (<em>int</em>) The rank of the key. 0=silence, 1=1st key after a silence, etc.</li>
<li><strong>is<em>nil</em>shape</strong>: (<em>bool</em>) True is the key is of the form "-V", i.e. no consonant</li>
<li><strong>is<em>nil</em>pos</strong>: (<em>bool</em>) True is the key is of the form "C-", i.e. no vowel</li>
</ul>

<h5>Returns</h5>

<ul>
<li><strong>(d1</strong>: float, d2: float)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">predict_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">is_nil_shape</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_nil_pos</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [D1;D2] the moments when fingers are changing.</span>

<span class="sd">        It is considered but not proved that:</span>

<span class="sd">        - D1 is after M1; and</span>
<span class="sd">        - D2 is before M2;</span>
<span class="sd">        - [D1;D2] is a relative fast change and must occur asap.</span>

<span class="sd">        :param rank: (int) The rank of the key. 0=silence, 1=1st key after a silence, etc.</span>
<span class="sd">        :param is_nil_shape: (bool) True is the key is of the form &quot;-V&quot;, i.e. no consonant</span>
<span class="sd">        :param is_nil_pos: (bool) True is the key is of the form &quot;C-&quot;, i.e. no vowel</span>
<span class="sd">        :return: (d1: float, d2: float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_shp_to_neutral</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_shp_from_neutral</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a3a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_a1a3_avg_duration</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_nil_pos</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">d1a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">1.15</span>
            <span class="n">d2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.55</span>
        <span class="k">elif</span> <span class="n">is_nil_shape</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">d1a1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">1.8</span><span class="p">)</span>
            <span class="n">d2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.2</span>
        <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">d1a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.8</span>
            <span class="n">d2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.6</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d1a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.65</span>
            <span class="n">d2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.4</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">d1a1</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">+</span> <span class="n">d2a1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
</code></pre></div>

    </details>


</section>
<section>
<h3 id="#private_fct_WhenTransitionPredictorRevisedRules">Private functions</h3>
<h4>_predict_pos_to_neutral</h4>

    <article class="docstring">
<p><em>Predict [M1;M2] for a destination key NN.</em></p>

<p>This transition is delayed compared to the other ones.</p>

<h5>Returns</h5>

<ul>
<li>tuple(<em>float</em>, <em>float</em>)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_predict_pos_to_neutral</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [M1;M2] for a destination key NN.</span>

<span class="sd">        This transition is delayed compared to the other ones.</span>

<span class="sd">        :return: tuple(float, float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">a3a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_static_duration</span><span class="p">()</span>
    <span class="n">m1a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.1</span>
    <span class="n">m2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">1.25</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">m1a1</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">+</span> <span class="n">m2a1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
</code></pre></div>

    </details>


<h4>_predict_pos_from_neutral</h4>

    <article class="docstring">
<p><em>Predict [M1;M2] from a silence to the first key on the face.</em></p>

<p>This transition is anticipated compared to the other ones.</p>

<h5>Returns</h5>

<ul>
<li>tuple(<em>float</em>, <em>float</em>)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_predict_pos_from_neutral</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [M1;M2] from a silence to the first key on the face.</span>

<span class="sd">        This transition is anticipated compared to the other ones.</span>

<span class="sd">        :return: tuple(float, float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">a3a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_a1a3_avg_duration</span><span class="p">()</span>
    <span class="n">m1a1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">1.6</span><span class="p">)</span>
    <span class="n">m2a1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">m1a1</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">m2a1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
</code></pre></div>

    </details>


<h4>_predict_pos_generic</h4>

    <article class="docstring">
<p><em>Predict [M1;M2] for a destination key 'C', 'V' or 'CV'.</em></p>

<p>Prediction algorithm is as follows:</p>

<blockquote>
  <p>if 'C':
          m1 = a1 - (a3a1 * 1.60)
          m2 = a1 - (a3a1 * 0.30)
      elif 'V':
          m1 = a1 - (a3a1 * 2.40)
          m2 = a1 - (a3a1 * 0.60)
      else:
          m1 = a1 - (a3a1 * 0.80)
          if 2nd_key:
              m2 = a1
          else
              m2 = a1 + (a3a1 * 0.11)</p>
</blockquote>

<h5>Parameters</h5>

<ul>
<li><strong>rank</strong>: (<em>int</em>) Rank of the key into the speech segment</li>
<li><strong>is<em>nil</em>shape</strong>: (<em>bool</em>) True is the key is of the form "-V", i.e. no consonant</li>
<li><strong>is<em>nil</em>pos</strong>: (<em>bool</em>) True is the key is of the form "C-", i.e. no vowel</li>
</ul>

<h5>Raises</h5>

<ul>
<li><em>ValueError</em>: invalid rank. It must be &gt; 1.</li>
</ul>

<h5>Returns</h5>

<ul>
<li>tuple(<em>float</em>, <em>float</em>)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_predict_pos_generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">is_nil_shape</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_nil_pos</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [M1;M2] for a destination key &#39;C&#39;, &#39;V&#39; or &#39;CV&#39;.</span>

<span class="sd">        Prediction algorithm is as follows:</span>
<span class="sd">        &gt;    if &#39;C&#39;:</span>
<span class="sd">        &gt;         m1 = a1 - (a3a1 * 1.60)</span>
<span class="sd">        &gt;         m2 = a1 - (a3a1 * 0.30)</span>
<span class="sd">        &gt;     elif &#39;V&#39;:</span>
<span class="sd">        &gt;         m1 = a1 - (a3a1 * 2.40)</span>
<span class="sd">        &gt;         m2 = a1 - (a3a1 * 0.60)</span>
<span class="sd">        &gt;     else:</span>
<span class="sd">        &gt;         m1 = a1 - (a3a1 * 0.80)</span>
<span class="sd">        &gt;         if 2nd_key:</span>
<span class="sd">        &gt;             m2 = a1</span>
<span class="sd">        &gt;         else</span>
<span class="sd">        &gt;             m2 = a1 + (a3a1 * 0.11)</span>

<span class="sd">        :param rank: (int) Rank of the key into the speech segment</span>
<span class="sd">        :param is_nil_shape: (bool) True is the key is of the form &quot;-V&quot;, i.e. no consonant</span>
<span class="sd">        :param is_nil_pos: (bool) True is the key is of the form &quot;C-&quot;, i.e. no vowel</span>
<span class="sd">        :raises: ValueError: invalid rank. It must be &gt; 1.</span>
<span class="sd">        :return: tuple(float, float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">is_nil_shape</span><span class="p">,</span> <span class="n">is_nil_pos</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For the generic prediction, nil_shape and nil_pos can&#39;t be both True together.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For the generic prediction, rank must be &gt;= 2.&#39;</span><span class="p">)</span>
    <span class="n">a3a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_a1a3_avg_duration</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">is_nil_pos</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">m1a1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">1.6</span><span class="p">)</span>
        <span class="n">m2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.3</span>
    <span class="k">elif</span> <span class="n">is_nil_shape</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">m1a1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">2.4</span><span class="p">)</span>
        <span class="n">m2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m1a1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">m2a1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.11</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">m1a1</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">+</span> <span class="n">m2a1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
</code></pre></div>

    </details>


<h4>_predict_shp_to_neutral</h4>

    <article class="docstring">
<p><em>Predict [D1;D2] for a destination key NN.</em></p>

<p>[A1;A3] is a silence, so the transition is from a previous sounded key
(CV, -V or C-) to the neutral one.</p>

<h5>Returns</h5>

<ul>
<li>tuple(<em>float</em>, <em>float</em>)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_predict_shp_to_neutral</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [D1;D2] for a destination key NN.</span>

<span class="sd">        [A1;A3] is a silence, so the transition is from a previous sounded key</span>
<span class="sd">        (CV, -V or C-) to the neutral one.</span>

<span class="sd">        :return: tuple(float, float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">a3a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_static_duration</span><span class="p">()</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">+</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.4</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">+</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.7</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
</code></pre></div>

    </details>


<h4>_predict_shp_from_neutral</h4>

    <article class="docstring">
<p><em>Predict [D1;D2] from a key NN to a facial one.</em></p>

<h5>Returns</h5>

<ul>
<li>tuple(<em>float</em>, <em>float</em>)</li>
</ul>

    </article>


    <details>
    <summary>
View Source
    </summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_predict_shp_from_neutral</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predict [D1;D2] from a key NN to a facial one.</span>

<span class="sd">        :return: tuple(float, float)</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">a3a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_a1a3_avg_duration</span><span class="p">()</span>
    <span class="n">d1a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">1.3</span>
    <span class="n">d2a1</span> <span class="o">=</span> <span class="n">a3a1</span> <span class="o">*</span> <span class="mf">0.9</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">d1a1</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">d2a1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
</code></pre></div>

    </details>


</section>
</section>    </section>    </main>
    
            <footer>
                <p class="copyright">Copyright (C) 2022-2026 Brigitte Bigi, CNRS, Laboratoire Parole et Langage, Aix-en-Provence, France</p>
            </footer>
        
</body>
</html>
